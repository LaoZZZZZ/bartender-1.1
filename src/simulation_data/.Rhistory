setwd("/home/laozzzzz/Documents/barcode_single_end/simulation_data");
Sys.time()
set.seed(23)
mutationCandidates = rbind(c(1,2,3), c(0,2,3), c(0,1,3), c(0,1,2))
mutA=function(n) sample(c(1,2,3),n,replace=T);
mutC=function(n) sample(c(0,2,3),n,replace=T);
mutG=function(n) sample(c(0,1,3),n,replace=T);
mutT=function(n) sample(c(0,1,2),n,replace=T);
bc.letter = c(0,1,2,3);
# Generate the base pair matrix.
# Each row represents a barcoede.
# This function guaruantees that each row of output is unique.
# The first column is the coded bardode.
# The remaining columns are base pair at each position.
generateUniquebpMatrix <- function(n.bc, len.bc, letters) {
difference = n.bc
bc.bp.mat = c()
bc.mat = c()
while(TRUE) {
# Generate next batch of base pair matrix
temp.bc.bp.mat = matrix(sample(bc.letter, difference*len.bc,  replace=T), nc=len.bc);
# Transfer the base pair matrix into integer
# for finding new barcodes that do not appear in the final result.
temp.bc.mat = encodeDNAMatrix(temp.bc.bp.mat)
temp.bc.mat = temp.bc.mat[!(temp.bc.mat %in% bc.mat)]
unique.temp.bc.mat = temp.bc.bp.mat[!duplicated(temp.bc.mat),]
bc.bp.mat = rbind(bc.bp.mat, unique.temp.bc.mat)
bc.mat = c(bc.mat, temp.bc.mat)
difference = n.bc - nrow(bc.bp.mat)
if (difference == 0) {
break
}
}
data = cbind(bc.mat, bc.bp.mat )
return(data)
}
# Given a base pair matrix
# Convert this matrix to coded integer row-wisely(each row represents a barcode).
encodeDNA <- function(bp.vector) {
bc.num.true = 0;
for (j in 1:length(bp.vector)){
bc.num.true = bc.num.true + bp.vector[j]*4^(j-1);
}
# Given a base pair matrix
# Convert this matrix to coded integer row-wisely(each row represents a barcode).
encodeDNA <- function(bp.vector) {
bc.num.true = 0;
for (j in 1:length(bp.vector)){
bc.num.true = bc.num.true + bp.vector[j]*4^(j-1);
}
return(bc.num.true)
}
encodeDNAMatrix <- function(bc.bp.mat) {
bc.num.true = 0;
for (j in 1:ncol(bc.bp.mat)){
bc.num.true = bc.num.true + bc.bp.mat[,j]*4^(j-1);
}
return(bc.num.true)
}
mutateBp <- function(bp) {
return(sample(mutationCandidates[bp + 1,],1,replace=T))
}
mutateBarcode <- function(row, bc.bp.mat, mutation.rate) {
num.mut = rpois(1, mutation.rate)
pos.mut = ceiling(runif(num.mut, 1, ncol(bc.bp.mat)-1))
base.mut = bc.bp.mat[row,pos.mut]
mutated_bp = sapply(base.mut, mutateBp)
bp.vector <- bc.bp.mat[row,]
bp.vector[pos.mut] = unlist(mutated_bp)
return(encodeDNA(bp.vector))
}
mutateDuplicateBarcodes <- function(bc.bp.mat, mutation.rate) {
pos = 1:nrow(bc.bp.mat)
col_size = ncol(bc.bp.mat)
batch_pos = rep(pos, bc.bp.mat[,col_size])
barcode_result = sapply(batch_pos, mutateBarcode, bc.bp.mat = bc.bp.mat, mutation.rate = mutation.rate)
return(barcode_result)
}
# Given the
sequenceBarcode <- function(sequence_error_rate, barcode_and_freq) {
col_size = ncol(barcode_and_freq)
mutation.rate = (col_size - 1) * sequence_error_rate
return(mutateDuplicateBarcodes(barcode_and_freq, mutation.rate))
}
sequenceBarcode2 <- function(r.e, bc.true.mat) {
n.bc = nrow(bc.true.mat)
col_size = ncol(bc.true.mat)
bc.freq = bc.true.mat[, col_size]
pos.bc.freq = rep(1:n.bc, bc.freq);
size.batch= n.bc;
n.batch=ceiling(length(pos.bc.freq)/n.bc);
batch.start= c(0:(n.batch-1))*size.batch+1;
batch.end = c(c(1:(n.batch-1))*size.batch, length(pos.bc.freq));
bc.num=NULL;
for (i.batch in 1:n.batch){
bc.true.mat.batch = bc.true.mat[pos.bc.freq[batch.start[i.batch]:batch.end[i.batch]],];
n.base = length(bc.true.mat.batch);
num.mut = rpois(1, n.base*r.e);
pos.mut = runif(num.mut, 1, n.base);
base.mut.0 = base.mut.1 = bc.true.mat.batch[pos.mut];
A.index = (base.mut.0==0); base.mut.1[A.index]=mutA(sum(A.index));
C.index = (base.mut.0==1); base.mut.1[C.index]=mutC(sum(C.index));
G.index = (base.mut.0==2); base.mut.1[G.index]=mutG(sum(G.index));
T.index = (base.mut.0==3); base.mut.1[T.index]=mutT(sum(T.index));
bc.true.mat.batch[pos.mut]=base.mut.1;
bc.true.mat.batch = matrix(bc.true.mat.batch, nc=len.bc);
bc.num.i = 0;
bc.num.i = encodeDNAMatrix(bc.true.mat.batch)
bc.num=c(bc.num, bc.num.i);
}
bc.num.unique = table(bc.num);
bc.num.unique.freq = cbind(as.numeric(names(bc.num.unique)), bc.num.unique);
bc.num.unique.freq[,1] <- format(bc.num.unique.freq[,1], scientific = FALSE)
return(bc.num.unique.freq)
}
# Some parameters that are used for this simulation.
# Most of these parameters are consistent with that paper.
n.bc = 1e5;     #number of barcodes in the initial generation.
number_reads =  # number of reads at each time point
generations_between_tp = 8 # Generations between two time points
saturate_population = 1e10
total_generations = 160  # The total number of generations in this evolution process.
len.bc = 20;    #barcode length
r.e = 0.02;     #error rate
###### Generate true barcode (bc) #################
# The first len.bc columns are the base pair at each position
# the last column is the coded barcodes
Sys.time()
bc.true.mat = generateUniquebpMatrix(n.bc, len.bc, bc.letter)
barcode.freq.lambda = 0.01
bc.freq = round(rexp(n.bc, barcode.freq.lambda));
# hist(bc.freq);
# sum(bc.freq);
bc.num.true.freq = cbind(bc.true.mat, bc.freq);
encoded_barcode = sequenceBarcode2(r.e, bc.num.true.freq[,-1])
Sys.time()
